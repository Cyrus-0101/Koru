<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Koru</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Koru</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a> <a href="https://github.com/Cyrus-0101/Koru/actions"><img src="https://github.com/Cyrus-0101/Koru/workflows/CI/badge.svg" alt="Build Status" style="pointer-events: none;" class="inline"/></a></p>
<blockquote class="doxtable">
<p>&zwj;<em>A lightweight, multi-platform game engine built in C using the Vulkan graphics API.</em> </p>
</blockquote>
<p>Koru is designed to be fast, portable, and easy to extend â€” providing a low-level foundation for game development across platforms including Windows, Linux, and soon consoles and mobile devices.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md2"></a>
ğŸ§  What Is Koru?</h1>
<p>Koru is a <b>C99-based game engine</b> focused on performance, portability, and modularity. It's ideal for developers who want fine-grained control over rendering, input, memory, and platform-specific functionality without the overhead of high-level abstractions.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
External libs (/engine/src/vendor/)</h2>
<ol type="1">
<li>stb-image.h - From <a href="https://github.com/nothings/stb">STB by Sean Barrett</a> - Lightweight way to handle and load images</li>
</ol>
<h2><a class="anchor" id="autotoc_md4"></a>
ğŸš€ Features:</h2>
<ul>
<li>Written entirely in <b>C99</b> â€“ minimal dependencies</li>
<li><b>Vulkan-based renderer</b> for high-performance graphics</li>
<li>Cross-platform: <b>Windows, Linux, Mac</b> (with future plans for consoles and mobile)</li>
<li>Modular architecture for <b>easy extension</b></li>
<li>Custom <b>memory allocators</b>, <b>logging</b>, <b>assertions</b>, and <b>data structures</b> etc</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md6"></a>
ğŸ–¼ Architecture</h1>
<p>The high-level architecture of Koru is divided into four main layers:</p>
<h2><a class="anchor" id="autotoc_md7"></a>
1. &lt;strong&gt;Platform Layer&lt;/strong&gt;</h2>
<p>Handles OS-specific functionality:</p>
<ul>
<li><b>Windowing</b>: Creates and manages windows on Windows/Linux/Mac.</li>
<li><b>Input</b>: Manages keyboard, mouse, and gamepad input.</li>
<li><b>File I/O</b>: Provides cross-platform file system access.</li>
<li><b>Console Output</b>: Handles logging and debugging output.</li>
<li><b>Memory Management</b>: Allocates and frees memory efficiently.</li>
<li><b>Renderer API Extensions</b>: Integrates with Vulkan for rendering.</li>
</ul>
<h2><a class="anchor" id="autotoc_md8"></a>
2. &lt;strong&gt;Core&lt;/strong&gt;</h2>
<p>Provides fundamental utilities and services:</p>
<ul>
<li><b>Logger</b>: Logs messages for debugging and monitoring.</li>
<li><b>Assertions</b>: Ensures correctness during development.</li>
<li><b>Data Structures</b>: Efficient containers like dynamic arrays, linked lists, etc.</li>
<li><b>Memory Allocators</b>: Custom allocators for optimized memory usage.</li>
<li><b>Math Library</b>: Vector, matrix, and quaternion operations.</li>
<li><b>Parsers</b>: Parses formats like XML, CSV, JSON, etc.</li>
<li><b>Engine Configuration</b>: Loads and manages engine settings.</li>
<li><b>Profiling</b>: Measures performance bottlenecks.</li>
<li><b>Async File I/O</b>: Asynchronous file operations for non-blocking I/O.</li>
<li><b>Localization</b>: Supports internationalization.</li>
<li><b>String Library</b>: String manipulation utilities.</li>
<li><b>Random Number Generator (RNG)</b>: Generates random numbers for simulations and AI.</li>
</ul>
<h2><a class="anchor" id="autotoc_md9"></a>
3. &lt;strong&gt;Resource Management&lt;/strong&gt;</h2>
<p>Manages various assets:</p>
<ul>
<li><b>Images</b>: Texture loading and caching.</li>
<li><b>Materials</b>: Shader and lighting configurations.</li>
<li><b>Meshes</b>: 3D model loading and processing.</li>
<li><b>Animations</b>: Skeletal animations and timeline systems.</li>
<li><b>World Maps</b>: Terrain and level data management.</li>
</ul>
<h2><a class="anchor" id="autotoc_md10"></a>
4. &lt;strong&gt;Application Layer&lt;/strong&gt;</h2>
<p>Contains higher-level systems:</p>
<ul>
<li><b>Renderer Front End</b>: GUI, camera management, post-processing effects.</li>
<li><b>Renderer Back End</b>: Scene graph, materials, shaders, meshes, textures.</li>
<li><b>Audio</b>: 2D/3D audio playback, effects, and spatial audio.</li>
<li><b>Others</b>: Animation/timelines, event system, ECS, state machines, collision/physics.</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md12"></a>
ğŸ“‹ Feature List</h1>
<p>Hereâ€™s a summary of the features to be implemented in v0.1:</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Core Features</h2>
<ul>
<li><b>Lightweight build system</b>: Simple scripts for compiling on Windows and Linux.</li>
<li><b>Low-level utilities</b>:<ul>
<li>Dynamic arrays</li>
<li>String handling</li>
<li>Memory allocators</li>
<li>Profiling tools</li>
<li>Assertions</li>
<li>Logging</li>
</ul>
</li>
<li><b>Platform layer</b>:<ul>
<li>Window creation and management</li>
<li>Input handling (keyboard, mouse, gamepad)</li>
<li>File I/O</li>
<li>Console output</li>
</ul>
</li>
<li><b>Renderer/API Abstraction Layer</b>: Uses Vulkan for cross-platform rendering.</li>
<li><b>Memory Management</b>: Custom allocators for efficient memory use.</li>
<li><b>Scenegraph/ECS</b>: Hierarchical scene management and entity-component-system architecture.</li>
<li><b>Profiling/Debugging utilities</b>: Tools for measuring performance and identifying bottlenecks.</li>
<li>**"Scripting" support via hot reloading**: Experimental support for scripting through hot-reloading mechanisms.</li>
</ul>
<h2><a class="anchor" id="autotoc_md14"></a>
Planned Features</h2>
<ul>
<li>Mobile and console support</li>
<li>Full audio subsystem</li>
<li>Physics and collision detection</li>
<li>Advanced animation system</li>
<li>Improved asset pipeline</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md16"></a>
ğŸ¨ Visuals</h1>
<p>Check out the diagrams included in the <code>assets/</code> folder to understand how everything fits together:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Diagram   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><img src="assets/Koru%20Engine%20Architecture.png" alt="Architecture" class="inline"/>   </td><td class="markdownTableBodyNone">High-level overview of system modules and interactions    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><img src="assets/Koru%20Project%20Structure.png" alt="Project Structure" class="inline"/>   </td><td class="markdownTableBodyNone">File structure and module organization    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><img src="assets/Koru%20v0.1%20Feature%20List.png" alt="Feature List v0.1" class="inline"/>   </td><td class="markdownTableBodyNone">Summary of current capabilities and roadmap   </td></tr>
</table>
<hr  />
<h1><a class="anchor" id="autotoc_md18"></a>
ğŸ“ Project Structure</h1>
<div class="fragment"><div class="line">.</div>
<div class="line">â”œâ”€â”€ assets</div>
<div class="line">â”‚   â”œâ”€â”€ Koru Engine Architecture.png</div>
<div class="line">â”‚   â”œâ”€â”€ Koru Project Structure.png</div>
<div class="line">â”‚   â”œâ”€â”€ Koru v0.1 Feature List.png</div>
<div class="line">â”‚   â””â”€â”€ shaders</div>
<div class="line">â”‚       â”œâ”€â”€ Builtin.ObjectShader.frag.glsl</div>
<div class="line">â”‚       â””â”€â”€ Builtin.ObjectShader.vert.glsl</div>
<div class="line">â”œâ”€â”€ bin</div>
<div class="line">â”‚   â”œâ”€â”€ assets</div>
<div class="line">â”‚   â”‚   â”œâ”€â”€ Koru Engine Architecture.png</div>
<div class="line">â”‚   â”‚   â”œâ”€â”€ Koru Project Structure.png</div>
<div class="line">â”‚   â”‚   â”œâ”€â”€ Koru v0.1 Feature List.png</div>
<div class="line">â”‚   â”‚   â””â”€â”€ shaders</div>
<div class="line">â”‚   â”‚       â”œâ”€â”€ Builtin.ObjectShader.frag.glsl</div>
<div class="line">â”‚   â”‚       â”œâ”€â”€ Builtin.ObjectShader.frag.spv</div>
<div class="line">â”‚   â”‚       â”œâ”€â”€ Builtin.ObjectShader.vert.glsl</div>
<div class="line">â”‚   â”‚       â””â”€â”€ Builtin.ObjectShader.vert.spv</div>
<div class="line">â”‚   â”œâ”€â”€ console.log</div>
<div class="line">â”‚   â”œâ”€â”€ libengine.so</div>
<div class="line">â”‚   â”œâ”€â”€ testbed</div>
<div class="line">â”‚   â””â”€â”€ tests</div>
<div class="line">â”œâ”€â”€ build-all.bat</div>
<div class="line">â”œâ”€â”€ build-all.sh</div>
<div class="line">â”œâ”€â”€ clean-all.bat</div>
<div class="line">â”œâ”€â”€ clean-all.sh</div>
<div class="line">â”œâ”€â”€ Doxyfile                                # Configuration for generating API documentation with Doxygen</div>
<div class="line">â”œâ”€â”€ engine</div>
<div class="line">â”‚   â”œâ”€â”€ build.bat                           # Windows: Builds engine DLL</div>
<div class="line">â”‚   â”œâ”€â”€ build.sh                            # Linux: Builds engine shared object (.so)</div>
<div class="line">â”‚   â””â”€â”€ src</div>
<div class="line">â”‚       â”œâ”€â”€ containers</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ darray.c                    # Implementation of dynamic array container</div>
<div class="line">â”‚       â”‚   â””â”€â”€ darray.h                    # Public interface for dynamic arrays</div>
<div class="line">â”‚       â”œâ”€â”€ core</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ application.c               # Application lifecycle implementation (init/run/shutdown)</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ application.h               # Public interface for the application system</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ asserts.h                   # Custom assertion macros and debugging utilities</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ clock.c</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ clock.h</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ event.c                     # Event system implementation (register/unregister/fire)</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ event.h                     # Public interface for event handling system</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ input.c</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ input.h</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ kmemory.c                   # Memory allocation system with tagging support</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ kmemory.h                   # Interface for tagged memory management</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ kstring.c</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ kstring.h</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ logger.c                    # Logging system with color-coded output</div>
<div class="line">â”‚       â”‚   â””â”€â”€ logger.h                    # Public interface for logging module</div>
<div class="line">â”‚       â”œâ”€â”€ defines.h                       # Common type definitions, macros, and platform detection</div>
<div class="line">â”‚       â”œâ”€â”€ entry.h                         # Entry point interface; declares create_game()</div>
<div class="line">â”‚       â”œâ”€â”€ game_types.h                    # Game-related types used across engine and game logic</div>
<div class="line">â”‚       â”œâ”€â”€ math</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ kmath.c</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ kmath.h</div>
<div class="line">â”‚       â”‚   â””â”€â”€ math_types.h</div>
<div class="line">â”‚       â”œâ”€â”€ memory</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ linear_allocator.c</div>
<div class="line">â”‚       â”‚   â””â”€â”€ linear_allocator.h</div>
<div class="line">â”‚       â”œâ”€â”€ platform</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ filesystem.c</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ filesystem.h</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ platform_android.c</div>
<div class="line">â”‚       |   â”œâ”€â”€ platform.h                 # Platform abstraction layer interface</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ platform_ios.c</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ platform_linux.c           # Linux-specific implementation of platform functions</div>
<div class="line">â”‚       â”‚   â”œâ”€â”€ platform_macos.c</div>
<div class="line">â”‚       â”‚   â””â”€â”€ platform_win32.c           # Windows-specific implementation of platform functions</div>
<div class="line">â”‚       â””â”€â”€ renderer</div>
<div class="line">â”‚           â”œâ”€â”€ renderer_backend.c</div>
<div class="line">â”‚           â”œâ”€â”€ renderer_backend.h</div>
<div class="line">â”‚           â”œâ”€â”€ renderer_frontend.c</div>
<div class="line">â”‚           â”œâ”€â”€ renderer_frontend.h</div>
<div class="line">â”‚           â”œâ”€â”€ renderer_types.inl</div>
<div class="line">â”‚           â””â”€â”€ vulkan</div>
<div class="line">â”‚               â”œâ”€â”€ shaders</div>
<div class="line">â”‚               â”‚   â”œâ”€â”€ vulkan_object_shader.c</div>
<div class="line">â”‚               â”‚   â””â”€â”€ vulkan_object_shader.h</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_backend.c</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_backend.h</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_buffer.c</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_buffer.h</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_command_buffer.c</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_command_buffer.h</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_device.c</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_device.h</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_fence.c</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_fence.h</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_framebuffer.c</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_framebuffer.h</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_image.c</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_image.h</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_pipeline.c</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_pipeline.h</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_platform.h</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_renderpass.c</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_renderpass.h</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_shader_utils.c</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_shader_utils.h</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_swapchain.c</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_swapchain.h</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_types.inl</div>
<div class="line">â”‚               â”œâ”€â”€ vulkan_utils.c</div>
<div class="line">â”‚               â””â”€â”€ vulkan_utils.h</div>
<div class="line">â”œâ”€â”€ LICENSE                                 # MIT License file</div>
<div class="line">â”œâ”€â”€ Makefile.engine.linux.mak</div>
<div class="line">â”œâ”€â”€ Makefile.engine.windows.mak</div>
<div class="line">â”œâ”€â”€ Makefile.testbed.linux.mak</div>
<div class="line">â”œâ”€â”€ Makefile.testbed.windows.mak</div>
<div class="line">â”œâ”€â”€ post-build.bat</div>
<div class="line">â”œâ”€â”€ post-build.sh</div>
<div class="line">â”œâ”€â”€ README.md                               # This file - main project overview and guide</div>
<div class="line">â”œâ”€â”€ testbed</div>
<div class="line">|   â”œâ”€â”€ build.bat                           # Windows: Builds testbed application</div>
<div class="line">|   â”œâ”€â”€ build.sh                            # Linux: Builds testbed application</div>
<div class="line">|   â””â”€â”€ src</div>
<div class="line">|       â”œâ”€â”€ entry.c                         # Entry point for testbed app; implements create_game()</div>
<div class="line">|       â”œâ”€â”€ game.c                          # Testbed game logic (initialize/update/render stubs)</div>
<div class="line">|       â””â”€â”€ game.h                          # Interface for testbed game implementation</div>
<div class="line">â””â”€â”€ tests</div>
<div class="line">    â”œâ”€â”€ build.bat</div>
<div class="line">    â”œâ”€â”€ build.sh</div>
<div class="line">    â””â”€â”€ src</div>
<div class="line">        â”œâ”€â”€ expect.h</div>
<div class="line">        â”œâ”€â”€ main.c</div>
<div class="line">        â”œâ”€â”€ memory</div>
<div class="line">        â”‚   â”œâ”€â”€ linear_allocator_tests.c</div>
<div class="line">        â”‚   â””â”€â”€ linear_allocator_tests.h</div>
<div class="line">        â”œâ”€â”€ test_manager.c</div>
<div class="line">        â””â”€â”€ test_manager.h</div>
<div class="line"> </div>
<div class="line">37 directories, 176 files   </div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md20"></a>
âš™ï¸ Build Scripts/Instructions</h1>
<p>Check tasks.json for sequence:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File   </th><th class="markdownTableHeadNone">Purpose   </th><th class="markdownTableHeadNone">Notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>engine/build.sh</code>   </td><td class="markdownTableBodyNone">Builds engine <code>.so</code> (shared lib) on Linux   </td><td class="markdownTableBodyNone">Uses Vulkan/XCB/X11    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>engine/build.bat</code>   </td><td class="markdownTableBodyNone">Builds engine <code>.dll</code> on Windows   </td><td class="markdownTableBodyNone">Links with Vulkan SDK    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>testbed/build.sh</code>   </td><td class="markdownTableBodyNone">Builds testbed app using engine <code>.so</code> on Linux   </td><td class="markdownTableBodyNone">Sets RPATH for easy loading    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>testbed/build.bat</code>   </td><td class="markdownTableBodyNone">Builds testbed <code>.exe</code> using engine <code>.dll</code> on Windows   </td><td class="markdownTableBodyNone">Links <code>.lib</code> import library    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>build-all.sh</code>   </td><td class="markdownTableBodyNone">Runs all Linux builds sequentially   </td><td class="markdownTableBodyNone">Checks for errors    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>build-all.bat</code>   </td><td class="markdownTableBodyNone">Runs all Windows builds sequentially   </td><td class="markdownTableBodyNone">Same as above but for Windows   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md21"></a>
Linux</h2>
<p>Make sure Clang and the Vulkan SDK are installed. Alternatively install VSCode and run the debugger (Commonly F5, and run the engine)</p>
<div class="fragment"><div class="line"># Give execution permissions</div>
<div class="line">chmod +x build-all.sh</div>
<div class="line"> </div>
<div class="line"># Run the build</div>
<div class="line">./build-all.sh</div>
</div><!-- fragment --><p>The output will be placed in <code>bin/</code>:</p>
<ul>
<li><code>libengine.so</code> â€“ The engine shared library</li>
<li><code>testbed</code> â€“ The testbed executable</li>
</ul>
<h2><a class="anchor" id="autotoc_md22"></a>
Windows</h2>
<p>Ensure:</p>
<ul>
<li>Clang is available</li>
<li>Vulkan SDK is installed and <code>VULKAN_SDK</code> environment variable is set</li>
<li>VS Code makes it easy to run the tasks in the .vscode/tasks.json file.</li>
</ul>
<p>Then run:</p>
<div class="fragment"><div class="line">build-all.bat</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md23"></a>
Building Docs</h1>
<p>To generate our Doxygen documentation, run:</p>
<div class="fragment"><div class="line">doxygen Doxyfile</div>
</div><!-- fragment --><p>Output files:</p>
<ul>
<li><code>bin\engine.dll</code></li>
<li><code>bin\testbed.exe</code></li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md25"></a>
ğŸ”® Roadmap</h1>
<p>Plans to expand Koru include:</p>
<ul>
<li>âœ… <b>Rendering Layer</b><ul>
<li>[ ] Vulkan renderer initialization</li>
<li>[ ] Swapchain setup</li>
<li>[ ] Command buffers, pipelines, shaders</li>
</ul>
</li>
<li>âœ… <b>Input System</b><ul>
<li>[ ] Keyboard/mouse/gamepad support</li>
<li>[ ] Input mapping and event system</li>
</ul>
</li>
<li>âœ… <b>Asset Management</b><ul>
<li>[ ] Texture loader</li>
<li>[ ] Mesh format and loader</li>
<li>[ ] Material system</li>
</ul>
</li>
<li>âœ… <b>Audio System</b><ul>
<li>[ ] Basic sound playback</li>
<li>[ ] Cross-platform audio backend</li>
</ul>
</li>
<li>âœ… <b>Multi-Platform Support</b><ul>
<li>[ ] Console (PlayStation, Xbox, Switch)</li>
<li>[ ] Mobile (Android/iOS)</li>
</ul>
</li>
<li>âœ… <b>Editor Tools</b><ul>
<li>[ ] Simple scene editor</li>
<li>[ ] Asset pipeline tools</li>
</ul>
</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md27"></a>
ğŸ’¡ Want to Help?</h1>
<p>Contributions are welcome! Whether you're interested in:</p>
<ul>
<li>Writing documentation</li>
<li>Implementing new features</li>
<li>Fixing bugs</li>
<li>Improving tooling or build scripts</li>
</ul>
<p>Feel free to open an issue or PR!</p>
<hr  />
<h1><a class="anchor" id="autotoc_md29"></a>
ğŸ“„ License</h1>
<p>This project is licensed under the MIT License â€“ see the [LICENSE](LICENSE) file for details.</p>
<div class="fragment"><div class="line">## ğŸš€ Next Steps</div>
<div class="line"> </div>
<div class="line">TO-DO: Add:</div>
<div class="line"> </div>
<div class="line">- âœ… A **Getting Started Guide** (`docs/getting-started.md`)</div>
<div class="line">- âœ… A **Contribution Guide** (`CONTRIBUTING.md`)</div>
<div class="line">- âœ… A **Code of Conduct** (`CODE_OF_CONDUCT.md`)</div>
<div class="line">- âœ… GitHub Actions for CI builds (optional)</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md31"></a>
ğŸ® Koru Engine â€“ Rendering System (Vulkan)</h1>
<blockquote class="doxtable">
<p>&zwj;<em>A deep dive into how Koru sets up its Vulkan-based rendering system â€” from instance creation to frame submission.</em> </p>
</blockquote>
<p>Koru is a <b>low-level game engine</b> written in C99 that uses the <b>Vulkan graphics API</b> for rendering. This document explains the <b>entire rendering pipeline setup</b> used in Koru, including:</p><ul>
<li>Instance creation</li>
<li>Physical device selection</li>
<li>Logical device creation</li>
<li>Surface &amp; swapchain setup</li>
<li>Render passes</li>
<li>Framebuffers</li>
<li>Command buffers</li>
</ul>
<p>This guide assumes some basic knowledge of C and Vulkan concepts. If you're new to Vulkan, this will help understand whatâ€™s happening behind the scenes as you run the testbed.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md33"></a>
ğŸ§  Why Use Vulkan?</h2>
<p>Vulkan gives developers <b>explicit control over GPU operations</b>. It allows fine-grained access to queues, memory, and rendering pipelines â€” which is great for performance, but comes at the cost of complexity.</p>
<p>Koru abstracts much of that complexity using a <b>modular architecture</b>, allowing you to build a rendering system step-by-step without needing to manage everything manually every time.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md35"></a>
ğŸ“¦ High-Level Architecture (Render Layer)</h2>
<div class="fragment"><div class="line">+------------------+</div>
<div class="line">|   Application    |</div>
<div class="line">|     Logic        |</div>
<div class="line">|  (game.c)        |</div>
<div class="line">+------------------+</div>
<div class="line">         |</div>
<div class="line">         v</div>
<div class="line">+------------------+</div>
<div class="line">|   Renderer       |</div>
<div class="line">|   Frontend       |</div>
<div class="line">| (renderer_frontend.h/c) |</div>
<div class="line">+------------------+</div>
<div class="line">         |</div>
<div class="line">         v</div>
<div class="line">+------------------+</div>
<div class="line">|   Platform       |</div>
<div class="line">|   Abstraction    |</div>
<div class="line">| (platform_linux.c)|</div>
<div class="line">+------------------+</div>
<div class="line">         |</div>
<div class="line">         v</div>
<div class="line">+------------------+</div>
<div class="line">|   Vulkan         |</div>
<div class="line">|   Device         |</div>
<div class="line">| (vulkan_device.c/h) |</div>
<div class="line">+------------------+</div>
<div class="line">         |</div>
<div class="line">         v</div>
<div class="line">+------------------+</div>
<div class="line">|   Swapchain      |</div>
<div class="line">|   Management     |</div>
<div class="line">| (vulkan_swapchain.c/h) |</div>
<div class="line">+------------------+</div>
<div class="line">         |</div>
<div class="line">         v</div>
<div class="line">+------------------+</div>
<div class="line">|   Render Pass /  |</div>
<div class="line">|   Framebuffer    |</div>
<div class="line">| (vulkan_renderpass.c/h) |</div>
<div class="line">+------------------+</div>
<div class="line">         |</div>
<div class="line">         v</div>
<div class="line">+------------------+</div>
<div class="line">|   Image          |</div>
<div class="line">|   Management     |</div>
<div class="line">| (vulkan_image.c/h) |</div>
<div class="line">+------------------+</div>
<div class="line">         |</div>
<div class="line">         v</div>
<div class="line">+------------------+</div>
<div class="line">|   Command Buffer |</div>
<div class="line">|   Submission     |</div>
<div class="line">| (renderer_frontend.c) |</div>
<div class="line">+------------------+</div>
</div><!-- fragment --><p>This shows how each module fits into the overall rendering flow.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md37"></a>
ğŸ› ï¸ The Full Rendering Setup Process</h2>
<p>Letâ€™s walk through <b>each stage of the rendering setup process</b>, with real code examples from the engine.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md39"></a>
1. ğŸ§± Create Vulkan Instance</h3>
<p>The first thing to do is creating a <b>VkInstance</b> â€” this connects the app to the Vulkan library.</p>
<div class="fragment"><div class="line"><span class="comment">// From vulkan_renderer_backend_initialize()</span></div>
<div class="line">VkApplicationInfo app_info = {VK_STRUCTURE_TYPE_APPLICATION_INFO};</div>
<div class="line">app_info.apiVersion = VK_MAKE_API_VERSION(0, 1, 4, 0);</div>
<div class="line">app_info.pApplicationName = application_name;</div>
<div class="line">app_info.applicationVersion = VK_MAKE_API_VERSION(0, 0, 0, 1);</div>
<div class="line">app_info.pEngineName = <span class="stringliteral">&quot;Koru Engine&quot;</span>;</div>
<div class="line">app_info.engineVersion = VK_MAKE_API_VERSION(0, 0, 0, 1);</div>
<div class="line"> </div>
<div class="line">VkInstanceCreateInfo create_info = {VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO};</div>
<div class="line">create_info.pApplicationInfo = &amp;app_info;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>** required_extensions = darray_create(<span class="keyword">const</span> <span class="keywordtype">char</span>*);</div>
<div class="line">darray_push(required_extensions, &amp;VK_KHR_SURFACE_EXTENSION_NAME);</div>
<div class="line">platform_get_required_extension_names(&amp;required_extensions);</div>
<div class="line"> </div>
<div class="line">create_info.enabledExtensionCount = darray_length(required_extensions);</div>
<div class="line">create_info.ppEnabledExtensionNames = required_extensions;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Enable validation layers if _DEBUG is defined</span></div>
<div class="line"><span class="preprocessor">#if defined(_DEBUG)</span></div>
<div class="line">    create_info.enabledLayerCount = required_validation_layer_count;</div>
<div class="line">    create_info.ppEnabledLayerNames = required_validation_layer_names;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">VK_CHECK(vkCreateInstance(&amp;create_info, context.allocator, &amp;context.instance));</div>
</div><!-- fragment --><p>âœ… This creates the <b>main connection to Vulkan</b>, enabling extensions and validation layers.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md41"></a>
2. ğŸ–¥ Create Window Surface</h3>
<p>Next, to create a <b>surface</b> â€” this is what connects the window to the GPU.</p>
<p>In Linux:</p>
<div class="fragment"><div class="line"><span class="comment">// platform_linux.c</span></div>
<div class="line">xcb_intern_atom_reply_t* wm_delete_reply = xcb_intern_atom_reply(...);</div>
<div class="line">state-&gt;wm_delete_win = wm_delete_reply-&gt;atom;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create surface</span></div>
<div class="line">VkXcbSurfaceCreateInfoKHR surface_create_info = {VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR};</div>
<div class="line">surface_create_info.connection = state-&gt;connection;</div>
<div class="line">surface_create_info.window = state-&gt;window;</div>
<div class="line"> </div>
<div class="line">vkCreateXcbSurfaceKHR(context-&gt;instance, &amp;surface_create_info, context-&gt;allocator, &amp;context-&gt;surface);</div>
</div><!-- fragment --><p>In Windows: The engine uses <code>vkCreateWin32SurfaceKHR()</code> instead.</p>
<p>âœ… A surface is essential because it defines where rendered frames go usually the screen or a window.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md43"></a>
3. ğŸ” Query Physical Devices</h3>
<p>Once an instance and a surface are ready, query available GPUs:</p>
<div class="fragment"><div class="line"><span class="comment">// vulkan_device.c</span></div>
<div class="line">u32 physical_device_count = 0;</div>
<div class="line">VK_CHECK(vkEnumeratePhysicalDevices(context-&gt;device.physical_device, &amp;physical_device_count, 0));</div>
<div class="line"> </div>
<div class="line">VkPhysicalDevice physical_devices[physical_device_count];</div>
<div class="line">VK_CHECK(vkEnumeratePhysicalDevices(context-&gt;instance, &amp;physical_device_count, physical_devices));</div>
</div><!-- fragment --><p>Then select one that meets requirements:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (u32 i = 0; i &lt; physical_device_count; ++i) {</div>
<div class="line">    VkPhysicalDeviceProperties properties;</div>
<div class="line">    vkGetPhysicalDeviceProperties(physical_devices[i], &amp;properties);</div>
<div class="line"> </div>
<div class="line">    VkPhysicalDeviceFeatures features;</div>
<div class="line">    vkGetPhysicalDeviceFeatures(physical_devices[i], &amp;features);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Check queue family support</span></div>
<div class="line">    vulkan_physical_device_queue_family_info queue_info = {};</div>
<div class="line">    vulkan_swapchain_support_info swapchain_support = {};</div>
<div class="line"> </div>
<div class="line">    b8 result = physical_device_meets_requirements(</div>
<div class="line">        physical_devices[i],</div>
<div class="line">        context-&gt;surface,</div>
<div class="line">        &amp;properties,</div>
<div class="line">        &amp;features,</div>
<div class="line">        &amp;requirements,</div>
<div class="line">        &amp;queue_info,</div>
<div class="line">        &amp;swapchain_support);</div>
<div class="line">}</div>
</div><!-- fragment --><p>ğŸ” Requirements include:</p><ul>
<li>Graphics/Compute/Present/Transfer queues</li>
<li>Extensions like <code>VK_KHR_SWAPCHAIN_EXTENSION_NAME</code></li>
<li>Features like <code>samplerAnisotropy</code></li>
<li>Prefer discrete GPU (optional)</li>
</ul>
<hr  />
<h3><a class="anchor" id="autotoc_md45"></a>
4. ğŸ”„ Create Logical Device</h3>
<p>After selecting a suitable physical device, create a <b>logical device</b> to interface with the GPU.</p>
<div class="fragment"><div class="line"><span class="comment">// vulkan_device.c</span></div>
<div class="line">b8 present_shares_graphics_queue = (context-&gt;device.graphics_queue_index == context-&gt;device.present_queue_index);</div>
<div class="line">b8 transfer_shares_graphics_queue = (context-&gt;device.graphics_queue_index == context-&gt;device.transfer_queue_index);</div>
<div class="line"> </div>
<div class="line">u32 index_count = 1;</div>
<div class="line"><span class="keywordflow">if</span> (!present_shares_graphics_queue) index_count++;</div>
<div class="line"><span class="keywordflow">if</span> (!transfer_shares_graphics_queue) index_count++;</div>
<div class="line"> </div>
<div class="line">u32 indices[index_count];</div>
<div class="line">indices[0] = context-&gt;device.graphics_queue_index;</div>
<div class="line">...</div>
</div><!-- fragment --><p>Define the queues as needed:</p>
<div class="fragment"><div class="line">VkDeviceQueueCreateInfo queue_create_infos[index_count];</div>
<div class="line"><span class="keywordflow">for</span> (u32 i = 0; i &lt; index_count; ++i) {</div>
<div class="line">    queue_create_infos[i].sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;</div>
<div class="line">    queue_create_infos[i].queueFamilyIndex = indices[i];</div>
<div class="line">    queue_create_infos[i].queueCount = 1;</div>
<div class="line">    f32 queue_priority = 1.0f;</div>
<div class="line">    queue_create_infos[i].pQueuePriorities = &amp;queue_priority;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Finally, create the logical device:</p>
<div class="fragment"><div class="line">VkDeviceCreateInfo device_create_info = {VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO};</div>
<div class="line">device_create_info.queueCreateInfoCount = index_count;</div>
<div class="line">device_create_info.pQueueCreateInfos = queue_create_infos;</div>
<div class="line">device_create_info.pEnabledFeatures = &amp;device_features;</div>
<div class="line"> </div>
<div class="line">VK_CHECK(vkCreateDevice(context-&gt;device.physical_device, &amp;device_create_info, context-&gt;allocator, &amp;context-&gt;device.logical_device));</div>
</div><!-- fragment --><p>âœ… This creates a way to submit commands to the GPU.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md47"></a>
5. â± Get Queues</h3>
<p>Once the device is created, get handles to the actual queues:</p>
<div class="fragment"><div class="line">vkGetDeviceQueue(context-&gt;device.logical_device, context-&gt;device.graphics_queue_index, 0, &amp;context-&gt;device.graphics_queue);</div>
<div class="line">vkGetDeviceQueue(context-&gt;device.logical_device, context-&gt;device.present_queue_index, 0, &amp;context-&gt;device.present_queue);</div>
</div><!-- fragment --><p>These are used later to:</p><ul>
<li>Submit draw commands (<code>graphics_queue</code>)</li>
<li>Present frames (<code>present_queue</code>)</li>
<li>Copy data (<code>transfer_queue</code>)</li>
</ul>
<hr  />
<h3><a class="anchor" id="autotoc_md49"></a>
6. ğŸ”„ Query Swapchain Support</h3>
<p>Before creating a swapchain, check what formats and modes are supported:</p>
<div class="fragment"><div class="line"><span class="comment">// vulkan_device.c</span></div>
<div class="line"><span class="keywordtype">void</span> vulkan_device_query_swapchain_support(...) {</div>
<div class="line">    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &amp;out_support-&gt;capabilities);</div>
<div class="line">    vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &amp;out_support-&gt;format_count, 0);</div>
<div class="line">    vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &amp;out_support-&gt;present_mode_count, 0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This helps choose the best image format and presentation mode.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md51"></a>
7. ğŸ” Create Swapchain</h3>
<p>Now create the swapchain based on what the device supports:</p>
<div class="fragment"><div class="line"><span class="comment">// vulkan_swapchain.c</span></div>
<div class="line">VkSwapchainCreateInfoKHR create_info = {VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR};</div>
<div class="line">create_info.surface = context-&gt;surface;</div>
<div class="line">create_info.minImageCount = image_count;</div>
<div class="line">create_info.imageFormat = swapchain-&gt;image_format.format;</div>
<div class="line">create_info.imageExtent = swapchain_extent;</div>
<div class="line">create_info.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (context-&gt;device.graphics_queue_index != context-&gt;device.present_queue_index) {</div>
<div class="line">    u32 queueFamilyIndices[] = {</div>
<div class="line">        (u32)context-&gt;device.graphics_queue_index,</div>
<div class="line">        (u32)context-&gt;device.present_queue_index};</div>
<div class="line"> </div>
<div class="line">    create_info.imageSharingMode = VK_SHARING_MODE_CONCURRENT;</div>
<div class="line">    create_info.queueFamilyIndexCount = 2;</div>
<div class="line">    create_info.pQueueFamilyIndices = queueFamilyIndices;</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    create_info.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">VK_CHECK(vkCreateSwapchainKHR(context-&gt;device.logical_device, &amp;create_info, context-&gt;allocator, &amp;swapchain-&gt;handle));</div>
</div><!-- fragment --><p>ğŸ”„ The swapchain acts like a rotating carousel of images:</p><ul>
<li>One is being drawn</li>
<li>One is being displayed</li>
<li>One is waiting to be used next</li>
</ul>
<p>This avoids tearing and ensures smooth rendering.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md53"></a>
8. ğŸ–¼ Create Image Views</h3>
<p>Each image in the swapchain needs a <b>view</b> so the GPU can interpret it:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (u32 i = 0; i &lt; swapchain-&gt;image_count; ++i) {</div>
<div class="line">    VkImageViewCreateInfo view_info = {VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO};</div>
<div class="line">    view_info.image = swapchain-&gt;images[i];</div>
<div class="line">    view_info.viewType = VK_IMAGE_VIEW_TYPE_2D;</div>
<div class="line">    view_info.format = swapchain-&gt;image_format.format;</div>
<div class="line">    view_info.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</div>
<div class="line">    view_info.subresourceRange.baseMipLevel = 0;</div>
<div class="line">    view_info.subresourceRange.levelCount = 1;</div>
<div class="line">    view_info.subresourceRange.baseArrayLayer = 0;</div>
<div class="line">    view_info.layerCount = 1;</div>
<div class="line"> </div>
<div class="line">    VK_CHECK(vkCreateImageView(context-&gt;device.logical_device, &amp;view_info, context-&gt;allocator, &amp;swapchain-&gt;views[i]));</div>
<div class="line">}</div>
</div><!-- fragment --><p>ğŸ–¼ Each image view wraps a raw <code>VkImage</code>, defining how it's accessed (e.g., color attachment, depth buffer).</p>
<hr  />
<h3><a class="anchor" id="autotoc_md55"></a>
9. ğŸ§Š Detect Depth Format</h3>
<p>For depth testing, a compatible depth format is needed:</p>
<div class="fragment"><div class="line">b8 vulkan_device_detect_depth_format(vulkan_device* device) {</div>
<div class="line">    <span class="keyword">const</span> u64 candidate_count = 3;</div>
<div class="line">    VkFormat candidates[candidate_count] = {</div>
<div class="line">        VK_FORMAT_D32_SFLOAT,</div>
<div class="line">        VK_FORMAT_D32_SFLOAT_S8_UINT,</div>
<div class="line">        VK_FORMAT_D24_UNORM_S8_UINT};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (u64 i = 0; i &lt; candidate_count; ++i) {</div>
<div class="line">        VkFormatProperties props;</div>
<div class="line">        vkGetPhysicalDeviceFormatProperties(device-&gt;physical_device, candidates[i], &amp;props);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> ((props.optimalTilingFeatures &amp; VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT)) {</div>
<div class="line">            device-&gt;depth_format = candidates[i];</div>
<div class="line">            <span class="keywordflow">return</span> True;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    KERROR(<span class="stringliteral">&quot;No supported depth format found.&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> False;</div>
<div class="line">}</div>
</div><!-- fragment --><p>ğŸ§ƒ Once selected, create a depth/stencil image and its view.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md57"></a>
10. ğŸ¨ Create Render Pass</h3>
<p>The render pass defines how rendering works â€” what attachments to use, how they behave, and what subpasses exist.</p>
<div class="fragment"><div class="line"><span class="comment">// vulkan_renderpass.c</span></div>
<div class="line">VkAttachmentDescription attachments[2] = {};</div>
<div class="line">attachments[0].format = swapchain-&gt;image_format.format;</div>
<div class="line">attachments[0].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;</div>
<div class="line">attachments[0].storeOp = VK_ATTACHMENT_STORE_OP_STORE;</div>
<div class="line">attachments[0].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;</div>
<div class="line">attachments[0].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</div>
<div class="line">attachments[0].finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;</div>
<div class="line"> </div>
<div class="line">attachments[1].format = context-&gt;device.depth_format;</div>
<div class="line">attachments[1].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;</div>
<div class="line">attachments[1].storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;</div>
<div class="line">attachments[1].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</div>
<div class="line">attachments[1].finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;</div>
<div class="line"> </div>
<div class="line">VkSubpassDescription subpass = {};</div>
<div class="line">subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;</div>
<div class="line">subpass.colorAttachmentCount = 1;</div>
<div class="line">subpass.pColorAttachments = &amp;color_ref;</div>
<div class="line">subpass.pDepthStencilAttachment = &amp;depth_stencil_ref;</div>
<div class="line"> </div>
<div class="line">VkRenderPassCreateInfo info = {};</div>
<div class="line">info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;</div>
<div class="line">info.attachmentCount = 2;</div>
<div class="line">info.pAttachments = attachments;</div>
<div class="line">info.subpassCount = 1;</div>
<div class="line">info.pSubpasses = &amp;subpass;</div>
<div class="line"> </div>
<div class="line">VK_CHECK(vkCreateRenderPass(context-&gt;device.logical_device, &amp;info, context-&gt;allocator, &amp;renderpass-&gt;handle));</div>
</div><!-- fragment --><p>ğŸ¨ The render pass is like a <b>blueprint</b> â€” it tells the GPU:</p><ul>
<li>What kind of data it will write to</li>
<li>How to handle clearing and storing it</li>
<li>What layout transitions happen between steps</li>
</ul>
<hr  />
<h3><a class="anchor" id="autotoc_md59"></a>
11. ğŸ–¼ Create Framebuffers</h3>
<p>Framebuffers combine images and render passes:</p>
<div class="fragment"><div class="line">VkFramebufferCreateInfo fb_info = {VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO};</div>
<div class="line">fb_info.renderPass = renderpass-&gt;handle;</div>
<div class="line">fb_info.attachmentCount = 2;</div>
<div class="line">fb_info.pAttachments = attachments;</div>
<div class="line">fb_info.width = width;</div>
<div class="line">fb_info.height = height;</div>
<div class="line">fb_info.layers = 1;</div>
<div class="line"> </div>
<div class="line">VK_CHECK(vkCreateFramebuffer(device, &amp;fb_info, 0, &amp;framebuffer));</div>
</div><!-- fragment --><p>ğŸ–¼ Each framebuffer links:</p><ul>
<li>A color image from the swapchain</li>
<li>A depth/stencil image</li>
<li>The render pass that defines how to use them</li>
</ul>
<hr  />
<h3><a class="anchor" id="autotoc_md61"></a>
12. ğŸ—‚ Command Buffers and Submission</h3>
<p>Command buffers store drawing commands:</p>
<div class="fragment"><div class="line"><span class="comment">// Begin command recording</span></div>
<div class="line">VkCommandBufferBeginInfo begin_info = {VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};</div>
<div class="line">vkBeginCommandBuffer(command_buffer, &amp;begin_info);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Record draw commands here...</span></div>
<div class="line"> </div>
<div class="line">vkEndCommandBuffer(command_buffer);</div>
</div><!-- fragment --><p>Then submit to the GPU:</p>
<div class="fragment"><div class="line">VkSubmitInfo submit_info = {VK_STRUCTURE_TYPE_SUBMIT_INFO};</div>
<div class="line">submit_info.waitSemaphoreCount = 1;</div>
<div class="line">submit_info.pWaitSemaphores = &amp;image_available_semaphore;</div>
<div class="line">submit_info.commandBufferCount = 1;</div>
<div class="line">submit_info.pCommandBuffers = &amp;command_buffer;</div>
<div class="line"> </div>
<div class="line">VK_CHECK(vkQueueSubmit(graphics_queue, 1, &amp;submit_info, fence));</div>
</div><!-- fragment --><p>And finally present:</p>
<div class="fragment"><div class="line">VkPresentInfoKHR present_info = {VK_STRUCTURE_TYPE_PRESENT_INFO_KHR};</div>
<div class="line">present_info.swapchainCount = 1;</div>
<div class="line">present_info.pSwapchains = &amp;swapchain-&gt;handle;</div>
<div class="line">present_info.pImageIndices = &amp;image_index;</div>
<div class="line"> </div>
<div class="line">VkResult result = vkQueuePresentKHR(present_queue, &amp;present_info);</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md63"></a>
ğŸ§© Diagram: Full Rendering Flow</h2>
<div class="fragment"><div class="line">+-------------------+</div>
<div class="line">|   Application     |</div>
<div class="line">|   Entry Point     |</div>
<div class="line">| (application_run())|</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">|   Create Instance |</div>
<div class="line">| (vkCreateInstance)|</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">|   Create Surface  |</div>
<div class="line">| (vkCreateXcbSurfaceKHR) |</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">| Enumerate Physical|</div>
<div class="line">| Devices           |</div>
<div class="line">| (vkEnumeratePhysicalDevices) |</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">| Select Suitable   |</div>
<div class="line">| Physical Device   |</div>
<div class="line">| (select_physical_device) |</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">| Create Logical    |</div>
<div class="line">| Device            |</div>
<div class="line">| (vkCreateDevice)  |</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">| Get Queue Handles |</div>
<div class="line">| (vkGetDeviceQueue) |</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">| Query Swapchain   |</div>
<div class="line">| Support           |</div>
<div class="line">| (vkGetPhysicalDeviceSurface*) |</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">| Create Swapchain  |</div>
<div class="line">| (vkCreateSwapchainKHR) |</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">| Create Image Views|</div>
<div class="line">| (vkCreateImageView) |</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">| Detect Depth      |</div>
<div class="line">| Format            |</div>
<div class="line">| (vulkan_device_detect_depth_format) |</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">| Create Depth Image|</div>
<div class="line">| (vulkan_image_create) |</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">| Create Render Pass|</div>
<div class="line">| (vkCreateRenderPass) |</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">| Create Framebuffer|</div>
<div class="line">| (vkCreateFramebuffer) |</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">| Begin Main Loop   |</div>
<div class="line">| (vkAcquireNextImageKHR) |</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">| Begin Render Pass |</div>
<div class="line">| (vkCmdBeginRenderPass) |</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">| Record Draw       |</div>
<div class="line">| Commands          |</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">| End Render Pass   |</div>
<div class="line">| (vkCmdEndRenderPass) |</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">| Submit Command    |</div>
<div class="line">| Buffer to GPU     |</div>
<div class="line">| (vkQueueSubmit)   |</div>
<div class="line">+-------------------+</div>
<div class="line">           |</div>
<div class="line">           v</div>
<div class="line">+-------------------+</div>
<div class="line">| Present Frame     |</div>
<div class="line">| (vkQueuePresentKHR) |</div>
<div class="line">+-------------------+</div>
</div><!-- fragment --><p>This is the full <b>rendering loop</b> that happens every frame.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md65"></a>
ğŸ§° Key Structures Used</h2>
<h3><a class="anchor" id="autotoc_md66"></a>
&lt;tt&gt;vulkan_context&lt;/tt&gt;</h3>
<p>Tracks global Vulkan state: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>vulkan_context {</div>
<div class="line">    VkInstance instance;</div>
<div class="line">    VkSurfaceKHR surface;</div>
<div class="line">    VkDebugUtilsMessengerEXT debug_messenger;</div>
<div class="line">    vulkan_device device;</div>
<div class="line">    vulkan_swapchain swapchain;</div>
<div class="line">    u32 image_index;</div>
<div class="line">    u32 current_frame;</div>
<div class="line">    b8 recreating_swapchain;</div>
<div class="line">    i32 (*find_memory_index)(...);</div>
<div class="line">} vulkan_context;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md67"></a>
&lt;tt&gt;vulkan_device&lt;/tt&gt;</h3>
<p>Holds physical/logical device and queue info: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>vulkan_device {</div>
<div class="line">    VkPhysicalDevice physical_device;</div>
<div class="line">    VkDevice logical_device;</div>
<div class="line">    vulkan_swapchain_support_info swapchain_support;</div>
<div class="line">    i32 graphics_queue_index;</div>
<div class="line">    i32 present_queue_index;</div>
<div class="line">    i32 transfer_queue_index;</div>
<div class="line">    VkQueue graphics_queue;</div>
<div class="line">    VkQueue present_queue;</div>
<div class="line">    VkQueue transfer_queue;</div>
<div class="line">    VkPhysicalDeviceProperties properties;</div>
<div class="line">    VkPhysicalDeviceFeatures features;</div>
<div class="line">    VkPhysicalDeviceMemoryProperties memory;</div>
<div class="line">    VkFormat depth_format;</div>
<div class="line">} vulkan_device;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md68"></a>
&lt;tt&gt;vulkan_swapchain&lt;/tt&gt;</h3>
<p>Manages images and depth buffer: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>vulkan_swapchain {</div>
<div class="line">    VkSurfaceFormatKHR image_format;</div>
<div class="line">    u8 max_frames_in_flight;</div>
<div class="line">    VkSwapchainKHR handle;</div>
<div class="line">    u32 image_count;</div>
<div class="line">    VkImage* images;</div>
<div class="line">    VkImageView* views;</div>
<div class="line">    vulkan_image depth_attachment;</div>
<div class="line">} vulkan_swapchain;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md69"></a>
&lt;tt&gt;vulkan_renderpass&lt;/tt&gt;</h3>
<p>Defines clear values and viewport settings: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>vulkan_renderpass {</div>
<div class="line">    VkRenderPass handle;</div>
<div class="line">    f32 clear_r, clear_g, clear_b, clear_a;</div>
<div class="line">    f32 clear_depth;</div>
<div class="line">    u32 clear_stencil;</div>
<div class="line">    f32 viewport_x, viewport_y, viewport_w, viewport_h;</div>
<div class="line">    f32 scissor_x, scissor_y, scissor_w, scissor_h;</div>
<div class="line">} vulkan_renderpass;</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md71"></a>
ğŸ’¡ Why All This Is Needed</h2>
<p>Vulkan is explicit by design. Every operation must be described precisely. Here's why each part matters:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Component   </th><th class="markdownTableHeadNone">Purpose    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Instance</b>   </td><td class="markdownTableBodyNone">Connects app to Vulkan driver    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Surface</b>   </td><td class="markdownTableBodyNone">Links window to GPU output    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Physical Device</b>   </td><td class="markdownTableBodyNone">Represents the actual GPU    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Logical Device</b>   </td><td class="markdownTableBodyNone">Interface to the GPU    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Queues</b>   </td><td class="markdownTableBodyNone">Workers for graphics/present/transfer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Swapchain</b>   </td><td class="markdownTableBodyNone">Manages sequence of renderable images    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Images</b>   </td><td class="markdownTableBodyNone">Raw GPU memory to draw into    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Image Views</b>   </td><td class="markdownTableBodyNone">Define how to read/write those images    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Render Pass</b>   </td><td class="markdownTableBodyNone">Defines rendering rules (clear/store ops, layout)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Framebuffers</b>   </td><td class="markdownTableBodyNone">Combine images into something you can draw into    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Command Buffers</b>   </td><td class="markdownTableBodyNone">Store GPU commands to execute later   </td></tr>
</table>
<hr  />
<h2><a class="anchor" id="autotoc_md73"></a>
ğŸ§± Summary Table</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Module   </th><th class="markdownTableHeadNone">Responsibility    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vulkan_renderer_backend_initialize()</code>   </td><td class="markdownTableBodyNone">Creates instance, surface, and starts device setup    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>vulkan_device_create()</code>   </td><td class="markdownTableBodyNone">Selects physical device, creates logical device    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vulkan_device_query_swapchain_support()</code>   </td><td class="markdownTableBodyNone">Queries device capabilities for swapchain    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>vulkan_swapchain_create()</code>   </td><td class="markdownTableBodyNone">Initializes the swapchain and image views    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vulkan_device_detect_depth_format()</code>   </td><td class="markdownTableBodyNone">Finds a usable depth format    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>vulkan_renderpass_create()</code>   </td><td class="markdownTableBodyNone">Sets up how we render    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vulkan_command_buffer_begin()</code>   </td><td class="markdownTableBodyNone">Starts recording draw commands    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>vulkan_swapchain_present()</code>   </td><td class="markdownTableBodyNone">Presents the final image to the screen   </td></tr>
</table>
<hr  />
<h2><a class="anchor" id="autotoc_md75"></a>
ğŸ§ª Bonus: Sample Code for Acquiring an Image</h2>
<div class="fragment"><div class="line">b8 vulkan_swapchain_acquire_next_image_index(...) {</div>
<div class="line">    VkResult result = vkAcquireNextImageKHR(</div>
<div class="line">        context-&gt;device.logical_device,</div>
<div class="line">        swapchain-&gt;handle,</div>
<div class="line">        timeout_ns,</div>
<div class="line">        image_available_semaphore,</div>
<div class="line">        fence,</div>
<div class="line">        out_image_index);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR) {</div>
<div class="line">        vulkan_swapchain_recreate(context, width, height, swapchain);</div>
<div class="line">        <span class="keywordflow">return</span> False;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (result != VK_SUCCESS &amp;&amp; result != VK_SUBOPTIMAL_KHR) {</div>
<div class="line">        KFATAL(<span class="stringliteral">&quot;Failed to acquire swapchain image!&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> False;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> True;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function gets the next image from the swapchain â€” and triggers recreation if needed.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md77"></a>
ğŸš« Common Errors and Fixes</h2>
<h3><a class="anchor" id="autotoc_md78"></a>
âŒ &lt;tt&gt;VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_EXT&lt;/tt&gt;: No cache file</h3>
<p>Not critical â€” just means the shader cache doesn't exist yet.</p>
<hr  />
 </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
